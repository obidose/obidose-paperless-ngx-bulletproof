import textwrap
import subprocess
import sys
import shutil
from pathlib import Path
from .common import cfg, say, log, ok, warn, confirm, prompt

BASE_DIR = Path(__file__).resolve().parent.parent


def _traefik_running() -> bool:
    """Return True if a traefik service is already running."""
    try:
        res = subprocess.run(
            [
                "docker",
                "ps",
                "-q",
                "--filter",
                "label=com.docker.compose.service=traefik",
            ],
            capture_output=True,
            text=True,
            check=False,
        )
        return bool(res.stdout.strip())
    except Exception:
        return False


def _network_exists(name: str) -> bool:
    try:
        res = subprocess.run(
            ["docker", "network", "ls", "--format", "{{.Name}}"],
            capture_output=True,
            text=True,
            check=False,
        )
        return name in res.stdout.splitlines()
    except Exception:
        return False


def copy_helper_scripts() -> None:
    """Copy helper scripts and install bulletproof CLI."""
    log("Copying helper scripts and installing CLI")
    for name in ("backup.py", "restore.py"):
        src = BASE_DIR / "modules" / name
        dst = Path(cfg.stack_dir) / name
        if src.exists():
            dst.write_text(src.read_text())
            dst.chmod(0o755)
        else:
            warn(f"Missing helper script: {src}")

    bp_src = BASE_DIR / "tools" / "bulletproof.py"
    stack_cli = Path(cfg.stack_dir) / "bulletproof.py"
    global_cli = Path("/usr/local/bin/bulletproof")
    if bp_src.exists():
        stack_cli.write_text(bp_src.read_text())
        stack_cli.chmod(0o755)
        global_cli.write_text(bp_src.read_text())
        global_cli.chmod(0o755)
    else:
        warn(f"Missing bulletproof CLI: {bp_src}")


def cleanup_stack_dir() -> None:
    """Remove leftovers from an aborted install."""
    project = Path(cfg.stack_dir).name
    try:
        subprocess.run(
            ["docker", "compose", "-p", project, "down", "--volumes", "--remove-orphans"],
            check=False,
        )
    except Exception as e:
        warn(f"Failed to stop containers: {e}")
    try:
        res = subprocess.run(
            ["docker", "network", "inspect", "paperless_net", "-f", "{{len .Containers}}"],
            capture_output=True,
            text=True,
            check=False,
        )
        if res.returncode == 0 and res.stdout.strip() == "0":
            subprocess.run(["docker", "network", "rm", "paperless_net"], check=False)
    except Exception:
        pass
    try:
        shutil.rmtree(cfg.stack_dir)
        warn(f"Removed incomplete stack at {cfg.stack_dir}")
    except FileNotFoundError:
        pass
    except Exception as e:
        warn(f"Failed to clean up {cfg.stack_dir}: {e}")


def restore_existing_backup_if_present() -> bool:
    remote = f"{cfg.rclone_remote_name}:{cfg.rclone_remote_path}"
    try:
        res = subprocess.run(
            ["rclone", "lsd", remote], capture_output=True, text=True, check=False
        )
    except Exception:
        return False
    if res.returncode != 0:
        return False
    snaps = [line.split()[-1].rstrip("/") for line in res.stdout.splitlines() if line.strip()]
    if not snaps:
        return False
    snaps = sorted(snaps)
    if not confirm("Existing backups found. Restore now?", True):
        return False
    for idx, name in enumerate(snaps, 1):
        say(f"  {idx}) {name}")
    choice = prompt("Choose snapshot number", str(len(snaps)))
    try:
        snap = snaps[int(choice) - 1]
    except Exception:
        snap = snaps[-1]
    say(f"Restoring chain: {snap}")
    subprocess.run(
        [sys.executable, str(BASE_DIR / "modules" / "restore.py"), snap],
        check=True,
    )
    return True


def write_env_file() -> None:
    log(f"Writing {cfg.env_file}")
    if cfg.enable_traefik == "yes":
        paperless_url = f"https://{cfg.domain}"
    else:
        paperless_url = f"http://localhost:{cfg.http_port}"

    Path(cfg.stack_dir).mkdir(parents=True, exist_ok=True)
    content = textwrap.dedent(
        f"""
        # Generated by installer
        INSTANCE_NAME={cfg.instance_name}
        STACK_DIR={cfg.stack_dir}
        DATA_ROOT={cfg.data_root}

        PUID={cfg.puid}
        PGID={cfg.pgid}
        TZ={cfg.tz}

        PAPERLESS_ADMIN_USER={cfg.paperless_admin_user}
        PAPERLESS_ADMIN_PASSWORD={cfg.paperless_admin_password}
        PAPERLESS_URL={paperless_url}

        POSTGRES_VERSION={cfg.postgres_version}
        POSTGRES_DB={cfg.postgres_db}
        POSTGRES_USER={cfg.postgres_user}
        POSTGRES_PASSWORD={cfg.postgres_password}

        ENABLE_TRAEFIK={cfg.enable_traefik}
        DOMAIN={cfg.domain}
        LETSENCRYPT_EMAIL={cfg.letsencrypt_email}
        HTTP_PORT={cfg.http_port}

        RCLONE_REMOTE_NAME={cfg.rclone_remote_name}
        RCLONE_REMOTE_PATH={cfg.rclone_remote_path}
        KEEP_FULLS={cfg.keep_fulls}
        KEEP_INCS={cfg.keep_incs}
        CRON_FULL_TIME={cfg.cron_full_time}
        CRON_INCR_TIME={cfg.cron_incr_time}
        CRON_ARCHIVE_TIME={cfg.cron_archive_time}
        """
    ).strip() + "\n"
    Path(cfg.env_file).write_text(content)


def write_compose_file() -> None:
    log(f"Writing {cfg.compose_file} (Traefik={cfg.enable_traefik})")
    Path(cfg.stack_dir).mkdir(parents=True, exist_ok=True)
    traefik_running = _traefik_running()
    net_exists = _network_exists("paperless_net")
    net_ext = "\n    external: true" if net_exists else ""

    if cfg.enable_traefik == "yes":
        services = textwrap.dedent(
            f"""
            services:
              redis:
                image: redis:7-alpine
                restart: unless-stopped
                command: ["redis-server","--save","60","1","--loglevel","warning"]
                networks: [paperless]

              db:
                image: postgres:{cfg.postgres_version}-alpine
                restart: unless-stopped
                environment:
                  POSTGRES_DB: {cfg.postgres_db}
                  POSTGRES_USER: {cfg.postgres_user}
                  POSTGRES_PASSWORD: {cfg.postgres_password}
                volumes:
                  - {cfg.dir_db}:/var/lib/postgresql/data
                networks: [paperless]

              gotenberg:
                image: gotenberg/gotenberg:8
                restart: unless-stopped
                command: ["gotenberg","--chromium-disable-javascript=true"]
                networks: [paperless]

              tika:
                image: ghcr.io/paperless-ngx/tika:latest
                restart: unless-stopped
                volumes:
                  - {cfg.dir_tika_cache}:/cache
                networks: [paperless]

              paperless:
                image: ghcr.io/paperless-ngx/paperless-ngx:latest
                depends_on: [db, redis, gotenberg, tika]
                restart: unless-stopped
                environment:
                  PUID: {cfg.puid}
                  PGID: {cfg.pgid}
                  TZ: {cfg.tz}
                  PAPERLESS_REDIS: redis://redis:6379
                  PAPERLESS_DBHOST: db
                  PAPERLESS_DBPORT: 5432
                  PAPERLESS_DBNAME: {cfg.postgres_db}
                  PAPERLESS_DBUSER: {cfg.postgres_user}
                  PAPERLESS_DBPASS: {cfg.postgres_password}
                  PAPERLESS_ADMIN_USER: {cfg.paperless_admin_user}
                  PAPERLESS_ADMIN_PASSWORD: {cfg.paperless_admin_password}
                  PAPERLESS_URL: ${{PAPERLESS_URL}}
                  PAPERLESS_TIKA_ENABLED: "1"
                  PAPERLESS_TIKA_GOTENBERG_ENDPOINT: http://gotenberg:3000
                  PAPERLESS_TIKA_ENDPOINT: http://tika:9998
                  PAPERLESS_CONSUMER_POLLING: "10"
                volumes:
                  - {cfg.dir_data}:/usr/src/paperless/data
                  - {cfg.dir_media}:/usr/src/paperless/media
                  - {cfg.dir_export}:/usr/src/paperless/export
                  - {cfg.dir_consume}:/usr/src/paperless/consume
                labels:
                  - traefik.enable=true
                  - traefik.http.routers.paperless.rule=Host(`{cfg.domain}`)
                  - traefik.http.routers.paperless.entrypoints=websecure
                  - traefik.http.routers.paperless.tls.certresolver=le
                  - traefik.http.services.paperless.loadbalancer.server.port=8000
                networks: [paperless]
            """
        )
        if traefik_running:
            warn("Traefik already running; reusing existing instance")
        else:
            traefik_block = textwrap.dedent(
                f"""
              traefik:
                image: traefik:v3.0
                restart: unless-stopped
                command:
                  - --providers.docker=true
                  - --providers.docker.exposedbydefault=false
                  - --entrypoints.web.address=:80
                  - --entrypoints.websecure.address=:443
                  - --certificatesresolvers.le.acme.httpchallenge=true
                  - --certificatesresolvers.le.acme.httpchallenge.entrypoint=web
                  - --certificatesresolvers.le.acme.email={cfg.letsencrypt_email}
                  - --certificatesresolvers.le.acme.storage=/letsencrypt/acme.json
                ports:
                  - 80:80
                  - 443:443
                volumes:
                  - /var/run/docker.sock:/var/run/docker.sock:ro
                  - {cfg.stack_dir}/letsencrypt:/letsencrypt
                networks: [paperless]
                """
            )
            services += traefik_block
            Path(f"{cfg.stack_dir}/letsencrypt").mkdir(parents=True, exist_ok=True)
            Path(f"{cfg.stack_dir}/letsencrypt/acme.json").touch(exist_ok=True)
            Path(f"{cfg.stack_dir}/letsencrypt/acme.json").chmod(0o600)
    else:
        services = textwrap.dedent(
            f"""
            services:
              redis:
                image: redis:7-alpine
                restart: unless-stopped
                command: ["redis-server","--save","60","1","--loglevel","warning"]
                networks: [paperless]

              db:
                image: postgres:{cfg.postgres_version}-alpine
                restart: unless-stopped
                environment:
                  POSTGRES_DB: {cfg.postgres_db}
                  POSTGRES_USER: {cfg.postgres_user}
                  POSTGRES_PASSWORD: {cfg.postgres_password}
                volumes:
                  - {cfg.dir_db}:/var/lib/postgresql/data
                networks: [paperless]

              gotenberg:
                image: gotenberg/gotenberg:8
                restart: unless-stopped
                command: ["gotenberg","--chromium-disable-javascript=true"]
                networks: [paperless]

              tika:
                image: ghcr.io/paperless-ngx/tika:latest
                restart: unless-stopped
                volumes:
                  - {cfg.dir_tika_cache}:/cache
                networks: [paperless]

              paperless:
                image: ghcr.io/paperless-ngx/paperless-ngx:latest
                depends_on: [db, redis, gotenberg, tika]
                restart: unless-stopped
                environment:
                  PUID: {cfg.puid}
                  PGID: {cfg.pgid}
                  TZ: {cfg.tz}
                  PAPERLESS_REDIS: redis://redis:6379
                  PAPERLESS_DBHOST: db
                  PAPERLESS_DBPORT: 5432
                  PAPERLESS_DBNAME: {cfg.postgres_db}
                  PAPERLESS_DBUSER: {cfg.postgres_user}
                  PAPERLESS_DBPASS: {cfg.postgres_password}
                  PAPERLESS_ADMIN_USER: {cfg.paperless_admin_user}
                  PAPERLESS_ADMIN_PASSWORD: {cfg.paperless_admin_password}
                  PAPERLESS_URL: ${{PAPERLESS_URL}}
                  PAPERLESS_TIKA_ENABLED: "1"
                  PAPERLESS_TIKA_GOTENBERG_ENDPOINT: http://gotenberg:3000
                  PAPERLESS_TIKA_ENDPOINT: http://tika:9998
                  PAPERLESS_CONSUMER_POLLING: "10"
                ports:
                  - {cfg.http_port}:8000
                volumes:
                  - {cfg.dir_data}:/usr/src/paperless/data
                  - {cfg.dir_media}:/usr/src/paperless/media
                  - {cfg.dir_export}:/usr/src/paperless/export
                  - {cfg.dir_consume}:/usr/src/paperless/consume
                networks: [paperless]
            """
        )

    compose = (
        services
        + "networks:\n"
        + "  paperless:\n"
        + "    name: paperless_net\n"
        + ("    external: true\n" if net_exists else "")
    )
    Path(cfg.compose_file).write_text(compose.strip() + "\n")


def bring_up_stack() -> None:
    log("Starting containers…")
    subprocess.run(
        [
            "docker",
            "compose",
            "--env-file",
            cfg.env_file,
            "-f",
            cfg.compose_file,
            "up",
            "-d",
        ],
        check=True,
        cwd=cfg.stack_dir,
    )


def install_cron_backup() -> None:
    log(
        f"Installing backup cron (full: {cfg.cron_full_time}, incr: {cfg.cron_incr_time}, archive: {cfg.cron_archive_time or 'disabled'})"
    )
    crontab = Path("/etc/crontab")
    lines = [
        l
        for l in (crontab.read_text().splitlines() if crontab.exists() else [])
        if f"{cfg.stack_dir}/backup.py" not in l
    ]
    full_line = (
        f"{cfg.cron_full_time} root {cfg.stack_dir}/backup.py full >> {cfg.stack_dir}/backup.log 2>&1"
    )
    incr_line = (
        f"{cfg.cron_incr_time} root {cfg.stack_dir}/backup.py incr >> {cfg.stack_dir}/backup.log 2>&1"
    )
    lines.extend([full_line, incr_line])
    if cfg.cron_archive_time:
        archive_line = (
            f"{cfg.cron_archive_time} root {cfg.stack_dir}/backup.py archive >> {cfg.stack_dir}/backup.log 2>&1"
        )
        lines.append(archive_line)
    crontab.write_text("\n".join(lines) + "\n")
    subprocess.run(["systemctl", "restart", "cron"], check=True)


def show_status() -> None:
    if cfg.enable_traefik == "yes":
        url = f"https://{cfg.domain}"
    else:
        url = f"http://localhost:{cfg.http_port}"
    print()
    ok(f"Paperless-ngx should be reachable at: {url}")

